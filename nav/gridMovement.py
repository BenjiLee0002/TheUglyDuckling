# GridMovement class 
# Handles all grid based navigation for the robot

from .grid import Grid
from . import grassfire as gf 
import queue, time, math

class GridMovement:

	def __init__(self, grid, queue):
		# direction bytes
		self.fwd = b'\xA0'
		self.rev = b'\x0A'
		self.rotl = b'\x00'
		self.rotr = b'\xAA'
		self.strl = b'\x22'
		self.strr = b'\x88'

		# motion bytes
		self.allmotors = b'\x55'
		self.right = b'\x05'
		self.left = b'\x50'
		self.front = b'\x11'
		self.rear = b'\x44'
		self.left45 = b'\x14'
		self.right45 = b'\x41'
	
		self.grid = grid
		self.queue = queue
		self.current = (4,4) #Hardcoded should be (4,3)
		self.goal = (7,7) #Hardcoded for now. Should be generated by find_goal()
		self.facing = 0
		self.path = []
		self.movement = {
			(0,1): [self.fwd, self.allmotors, 0], (0, -1): [self.rev, self.allmotors, 180],
			(1,0): [self.strr, self.allmotors, 90], (-1, 0): [self.strl, self.allmotors, -90],
			(1,1): [self.fwd, b'\x00', 45], (-1, 1): [self.fwd, b'\x00', -45],
			(1,-1): [self.fwd, b'\x00', 135], (-1,-1): [self.fwd, b'\x00', -135]
			}

	# Not yet implemented
	# Sets grid.blocks closest block to goal.
	def find_goal(self):
		pass

	# Generates shortest path to goal using grassfire algorithim
	def find_path(self):
		visited = gf.search(self.grid, self.current, self.goal)
		self.path = gf.construct_path(self.grid, visited, self.current)

	# Follows the generated path by subtracting the next location
	# from self.current and using translate_dir() and self.movement
	# to determine the proper movement
	def follow_path(self):
		dist = 12 # Default distance we want to move
		# Loop with index so that we can check the next movement
		# along with curent move
		for index, mov in enumerate(self.path):
			currentResult = (mov[0] - self.current[0], mov[1] - self.current[1])
			currentResult = self.translate_dir(currentResult)
			diagonal = gf.is_diagonal(self.current, mov)
			end_of_path = index == len(self.path) - 1

			# Don't bother checking next move if it doesn't exist
			if (not end_of_path):
				nextMov = self.path[index+1]
				nextResult = (nextMov[0] - mov[0], nextMov[1] - mov[1])
				nextResult = self.translate_dir(nextResult)
				# If next move request is the same as current 
				# increase distance moved
				if (currentResult == nextResult):
					self.face(mov)	
					dist = dist +12
					self.current = mov
					# We want to skip over the rest of the loop
					# We're not ready to push a movement call to queue
					continue

			# if dist > 12 then we have duplicate movements
			# We will accelerate
			if(dist > 12):
				args = (self.movement[currentResult][0], dist)
				self.queue.put(['accelerate', args])
			# Otherwise normal movement
			else:
				# if mov is diagonal turn towards it first
				if(diagonal):
					self.face(mov)
				args = (self.movement[currentResult][0], dist, self.movement[currentResult][1])
				self.queue.put(['gridMove', args])
				# if mov was diagonal and we're not at end of path
				# turn towards the next mov
				if(diagonal and not end_of_path):
					self.face(self.path[index + 1])

			# reset distance in case there was a stacked call 
			dist = 12
			self.current = mov
		
		# face goal after following path
		self.face(self.goal)

	# Face a tile connected to current tile
	def face(self, obj):
		result = (obj[0] - self.current[0], obj[1] - self.current[1])
		result = self.translate_dir(result)
		degrees = self.movement[result][2]
		if( degrees > 0):
			self.queue.put(['turn', (self.rotr, degrees)])
		elif(degrees < 0):
			self.queue.put(['turn', (self.rotl, degrees*-1)])
		self.facing = self.facing + degrees
		self.trim_facing()

	# Should be called anytime facing is updated
	# Keeps facing between -180 and 180 
	def trim_facing(self):
		sign = 1
		if self.facing >0:
			sign = -1
		if (abs(self.facing) == 360):
			self.facing = 0 * sign
		elif( abs(self.facing) == 225):
			self.facing = 135 * sign
		elif(abs(self.facing) == 270):
			self.facing = 90 * sign
		elif(abs(self.facing) == 315):
			self.facing = 45 * sign
		elif( abs(self.facing) == 180): 
			self.facing = 180 * -1



	# Use facing to translate proper movement
	def translate_dir(self, mov, degrees=None):
		# Default to self.facing
		if (degrees is None):
			degrees = self.facing
		
		result = None
		if(degrees == 0):
			result = mov
		elif(degrees == 180 or degrees == -180):
			result = (mov[0] * -1, mov[1] * -1)
		elif(degrees == -90):
			result = (mov[1], mov[0] * -1)
		elif(degrees == 90):
			result = (mov[1] * -1, mov[0])
		# Translate diagonal facings
		elif(degrees == 45):
			x = mov[0] - mov[1]
			y = mov[1] + mov[0]
			if x is not 0:
				x = x/abs(x)
			if y is not 0:
				y = y/abs(y)
			result = (x,y)
		
		elif(degrees == -45):
			x = mov[0] + mov[1]
			y = mov[1] - mov[0]
			if x is not 0:
				x = x/abs(x)
			if y is not 0:
				y = y/abs(y)
			result = (x,y)

		elif(degrees == -135):
			result = self.translate_dir(mov, 45)
			result = (result[0] * -1, result[1] * -1)

		elif(degrees == 135):
			result = self.translate_dir(mov, -45)
			result = (result[0] * -1, result[1] * -1)

		return result

	def map(self, args):
		angle = math.radians(args[1])
		dist = args[2]
		result = None

		if abs(self.facing) == 45 or abs(self.facing) == 135:
			result = self.map_diag(angle, dist)
		else:
			result = self.map_reg(angle, dist)

		if (args[0] == 8):
			self.grid.add_obstacle(result)
		else:
			self.grid.add_target(result)

	def map_reg(self, angle, dist):
		left_side = angle < 0
		offset = 6

		a_length = math.cos(abs(angle)) * dist
		o_length = math.sin(abs(angle)) * dist

		x = math.ceil((o_length - offset)/12)
		y = math.ceil(a_length/12)

		if left_side:
			x = x * -1

		if self.facing == -90:
			x,y = y* -1, x
		elif self.facing == 90:
			x,y = y, x * -1
		elif self.facing == 180 or self.facing == -180:
			x,y = x * -1, y *-1

		return (self.current[0] + x, self.current[1] + y) 

	def map_diag(self, angle, dist):
		left_side = angle < 0
		angle = math.radians(45) - abs(angle)
		offset = math.sqrt(288) / 2

		a_length = math.cos(angle) * dist
		o_length = math.sin(angle) * dist

		if(not left_side):
			x = a_length
			y = o_length
		else:
			x = o_length
			y = a_length

		x = math.ceil((x - offset)/12)
		y = math.ceil((y - offset)/12)

		if(self.facing == -45):
			x,y = y * -1,x
		elif(self.facing == -135):
			x,y = x*-1,y*-1
		elif(self.facing == 135):
			x,y = y, x*-1

		return (self.current[0] + x, self.current[1] + y) 